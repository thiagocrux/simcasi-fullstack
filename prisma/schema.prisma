generator client {
  provider   = "prisma-client-js"
  engineType = "client"
}

datasource db {
  provider = "postgresql"
}

/// @description Role domain record representing application roles.
/// @note Soft-deleted `code` must be restored instead of re-inserted.
/// @invariant `code` is unique across active and deleted records.
model Role {
  id        String    @id @default(uuid()) @db.Uuid
  code      String    @unique
  label     String
  createdBy String?   @map("created_by") @db.Uuid
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedBy String?   @map("updated_by") @db.Uuid
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(6)
  deletedAt DateTime? @map("deleted_at") @db.Timestamptz(6)

  creator User? @relation("RolesCreated", fields: [createdBy], references: [id], onDelete: Restrict)
  updater User? @relation("RolesUpdated", fields: [updatedBy], references: [id], onDelete: Restrict)

  permission RolePermission[]
  users      User[]           @relation("UserRole")

  @@map("roles")
}

/// @description Permissions assigned to roles to define system capabilities.
/// @note Soft-deleted `code` must be restored instead of re-inserted.
/// @invariant `code` is unique across active and deleted records.
model Permission {
  id        String    @id @default(uuid()) @db.Uuid
  code      String    @unique
  label     String
  createdBy String?   @map("created_by") @db.Uuid
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedBy String?   @map("updated_by") @db.Uuid
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(6)
  deletedAt DateTime? @map("deleted_at") @db.Timestamptz(6)

  creator User? @relation("PermissionsCreated", fields: [createdBy], references: [id], onDelete: Restrict)
  updater User? @relation("PermissionsUpdated", fields: [updatedBy], references: [id], onDelete: Restrict)

  roles RolePermission[]

  @@map("permissions")
}

/// @description Join table for many-to-many relationship between Role and Permission.
/// @note No soft-delete; rows are added/removed directly.
model RolePermission {
  roleId       String @map("role_id") @db.Uuid
  permissionId String @map("permission_id") @db.Uuid

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
  @@map("roles_permissions")
}

/// @description User domain record representing application users and credentials.
/// @note Soft-deleted accounts must be restored on re-registration.
/// @invariant `email` is unique across active and deleted records.
model User {
  id        String    @id @default(uuid()) @db.Uuid
  name      String
  email     String    @unique
  password  String
  roleId    String    @map("role_id") @db.Uuid
  isSystem  Boolean   @default(false) @map("is_system")
  createdBy String?   @map("created_by") @db.Uuid
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedBy String?   @map("updated_by") @db.Uuid
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(6)
  deletedAt DateTime? @map("deleted_at") @db.Timestamptz(6)

  role    Role  @relation("UserRole", fields: [roleId], references: [id], onDelete: Restrict)
  creator User? @relation("UsersCreated", fields: [createdBy], references: [id], onDelete: Restrict)
  updater User? @relation("UsersUpdated", fields: [updatedBy], references: [id], onDelete: Restrict)

  sessions Session[]

  // Authorship relations.
  rolesCreated         Role[]         @relation("RolesCreated")
  rolesUpdated         Role[]         @relation("RolesUpdated")
  permissionsCreated   Permission[]   @relation("PermissionsCreated")
  permissionsUpdated   Permission[]   @relation("PermissionsUpdated")
  usersCreated         User[]         @relation("UsersCreated")
  usersUpdated         User[]         @relation("UsersUpdated")
  patientsCreated      Patient[]      @relation("PatientsCreated")
  patientsUpdated      Patient[]      @relation("PatientsUpdated")
  examsCreated         Exam[]         @relation("ExamsCreated")
  examsUpdated         Exam[]         @relation("ExamsUpdated")
  notificationsCreated Notification[] @relation("NotificationsCreated")
  notificationsUpdated Notification[] @relation("NotificationsUpdated")
  observationsCreated  Observation[]  @relation("ObservationsCreated")
  observationsUpdated  Observation[]  @relation("ObservationsUpdated")
  treatmentsCreated    Treatment[]    @relation("TreatmentsCreated")
  treatmentsUpdated    Treatment[]    @relation("TreatmentsUpdated")

  auditLogs           AuditLog[]
  passwordResetTokens PasswordResetToken[]

  @@index([roleId], name: "idx_users_role_id")
  @@map("users")
}

/// @description User sessions for authentication and security tracking.
/// @note Sessions are transient; must be invalidated on user deletion/restore.
model Session {
  id        String    @id @default(uuid()) @db.Uuid
  userId    String    @map("user_id") @db.Uuid
  issuedAt  DateTime  @default(now()) @map("issued_at") @db.Timestamptz(6)
  expiresAt DateTime  @map("expires_at") @db.Timestamptz(6)
  ipAddress String    @map("ip_address") @db.Inet
  userAgent String    @map("user_agent")
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(6)
  deletedAt DateTime? @map("deleted_at") @db.Timestamptz(6)

  user User @relation(fields: [userId], references: [id], onDelete: Restrict)

  @@index(userId, name: "idx_sessions_user_id")
  @@map("sessions")
}

/// @description Transient tokens for password recovery flows.
/// @note Single-use tokens with short expiration.
model PasswordResetToken {
  id        String    @id @default(uuid()) @db.Uuid
  userId    String    @map("user_id") @db.Uuid
  token     String    @unique
  expiresAt DateTime  @map("expires_at") @db.Timestamptz(6)
  usedAt    DateTime? @map("used_at") @db.Timestamptz(6)
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(6)
  deletedAt DateTime? @map("deleted_at") @db.Timestamptz(6)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index(userId, name: "idx_password_reset_tokens_user_id")
  @@map("password_reset_tokens")
}

/// @description Canonical Patient entity storing personal and clinical identifiers.
/// @note Soft-delete cascades to exams, notifications, observations, and treatments.
/// @invariant `cpf` and `sus_card_number` are unique across all records.
model Patient {
  id             String    @id @default(uuid()) @db.Uuid
  susCardNumber  String    @unique @map("sus_card_number")
  name           String
  cpf            String    @unique
  socialName     String?   @map("social_name")
  birthDate      DateTime  @map("birth_date") @db.Date
  race           String
  sex            String
  gender         String
  sexuality      String
  nationality    String
  schooling      String
  phone          String?
  email          String?
  motherName     String    @map("mother_name")
  fatherName     String?   @map("father_name")
  isDeceased     Boolean   @default(false) @map("is_deceased")
  monitoringType String    @map("monitoring_type")
  zipCode        String?   @map("zip_code")
  state          String
  city           String
  neighborhood   String
  street         String
  houseNumber    String    @map("house_number")
  complement     String?
  createdBy      String    @map("created_by") @db.Uuid
  createdAt      DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedBy      String?   @map("updated_by") @db.Uuid
  updatedAt      DateTime? @updatedAt @map("updated_at") @db.Timestamptz(6)
  deletedAt      DateTime? @map("deleted_at") @db.Timestamptz(6)

  creator User  @relation("PatientsCreated", fields: [createdBy], references: [id], onDelete: Restrict)
  updater User? @relation("PatientsUpdated", fields: [updatedBy], references: [id], onDelete: Restrict)

  exams         Exam[]
  notifications Notification[]
  observations  Observation[]
  treatments    Treatment[]

  @@index([createdBy], name: "idx_patients_created_by")
  @@index([updatedBy], name: "idx_patients_updated_by")
  @@map("patients")
}

/// @description Clinical examinations and test results for Patients.
/// @note Cascade-soft-deleted with Patient; independent deletions persist on restore.
model Exam {
  id                         String    @id @default(uuid()) @db.Uuid
  patientId                  String    @map("patient_id") @db.Uuid
  treponemalTestType         String    @map("treponemal_test_type")
  treponemalTestResult       String    @map("treponemal_test_result")
  treponemalTestDate         DateTime  @map("treponemal_test_date") @db.Date
  treponemalTestLocation     String    @map("treponemal_test_location")
  nontreponemalVdrlTest      String    @map("nontreponemal_vdrl_test")
  nontreponemalTestTitration String    @map("nontreponemal_test_titration")
  nontreponemalTestDate      DateTime  @map("nontreponemal_test_date") @db.Date
  otherNontreponemalTest     String?   @map("other_nontreponemal_test")
  otherNontreponemalTestDate DateTime? @map("other_nontreponemal_test_date") @db.Date
  referenceObservations      String    @map("reference_observations")
  createdBy                  String    @map("created_by") @db.Uuid
  createdAt                  DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedBy                  String?   @map("updated_by") @db.Uuid
  updatedAt                  DateTime? @updatedAt @map("updated_at") @db.Timestamptz(6)
  deletedAt                  DateTime? @map("deleted_at") @db.Timestamptz(6)

  patient Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)
  creator User    @relation("ExamsCreated", fields: [createdBy], references: [id], onDelete: Restrict)
  updater User?   @relation("ExamsUpdated", fields: [updatedBy], references: [id], onDelete: Restrict)

  @@index([patientId], name: "idx_exams_patient_id")
  @@index([createdBy], name: "idx_exams_created_by")
  @@index([updatedBy], name: "idx_exams_updated_by")
  @@map("exams")
}

/// @description SIMCASI notification records for epidemiologic monitoring.
/// @note Cascade-soft-deleted with Patient; independent deletions persist on restore.
model Notification {
  id           String    @id @default(uuid()) @db.Uuid
  patientId    String    @map("patient_id") @db.Uuid
  sinan        String
  observations String?
  createdBy    String    @map("created_by") @db.Uuid
  updatedBy    String?   @map("updated_by") @db.Uuid
  createdAt    DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime? @updatedAt @map("updated_at") @db.Timestamptz(6)
  deletedAt    DateTime? @map("deleted_at") @db.Timestamptz(6)

  patient Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)
  creator User    @relation("NotificationsCreated", fields: [createdBy], references: [id], onDelete: Restrict)
  updater User?   @relation("NotificationsUpdated", fields: [updatedBy], references: [id], onDelete: Restrict)

  @@index([patientId], name: "idx_notifications_patient_id")
  @@index([createdBy], name: "idx_notifications_created_by")
  @@index([updatedBy], name: "idx_notifications_updated_by")
  @@map("notifications")
}

/// @description Clinical observations and ad-hoc notes for patient monitoring.
/// @note Cascade-soft-deleted with Patient; independent deletions persist on restore.
model Observation {
  id                     String    @id @default(uuid()) @db.Uuid
  patientId              String    @map("patient_id") @db.Uuid
  observations           String?
  hasPartnerBeingTreated Boolean   @default(false) @map("has_partner_being_treated")
  createdBy              String    @map("created_by") @db.Uuid
  createdAt              DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedBy              String?   @map("updated_by") @db.Uuid
  updatedAt              DateTime? @updatedAt @map("updated_at") @db.Timestamptz(6)
  deletedAt              DateTime? @map("deleted_at") @db.Timestamptz(6)

  patient Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)
  creator User    @relation("ObservationsCreated", fields: [createdBy], references: [id], onDelete: Restrict)
  updater User?   @relation("ObservationsUpdated", fields: [updatedBy], references: [id], onDelete: Restrict)

  @@index([patientId], name: "idx_observations_patient_id")
  @@index([createdBy], name: "idx_observations_created_by")
  @@index([updatedBy], name: "idx_observations_updated_by")
  @@map("observations")
}

/// @description Medication and treatment lifecycle details for Patients.
/// @note Cascade-soft-deleted with Patient; independent deletions persist on restore.
model Treatment {
  id                 String    @id @default(uuid()) @db.Uuid
  patientId          String    @map("patient_id") @db.Uuid
  medication         String
  healthCenter       String    @map("health_center")
  startDate          DateTime  @map("start_date") @db.Date
  dosage             String
  observations       String?
  partnerInformation String?   @map("partner_information")
  createdBy          String    @map("created_by") @db.Uuid
  createdAt          DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedBy          String?   @map("updated_by") @db.Uuid
  updatedAt          DateTime? @updatedAt @map("updated_at") @db.Timestamptz(6)
  deletedAt          DateTime? @map("deleted_at") @db.Timestamptz(6)

  patient Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)
  creator User    @relation("TreatmentsCreated", fields: [createdBy], references: [id], onDelete: Restrict)
  updater User?   @relation("TreatmentsUpdated", fields: [updatedBy], references: [id], onDelete: Restrict)

  @@index([patientId], name: "idx_treatments_patient_id")
  @@index([createdBy], name: "idx_treatments_created_by")
  @@index([updatedBy], name: "idx_treatments_updated_by")
  @@map("treatments")
}

/// @description Immutable audit trail for all system entity changes.
/// @note Read-only and creation-only; updates and deletions are strictly forbidden.
model AuditLog {
  id         String   @id @default(uuid()) @db.Uuid
  userId     String   @map("user_id") @db.Uuid
  action     String
  entityName String   @map("entity_name")
  entityId   String   @map("entity_id") @db.Uuid
  oldValues  Json?    @map("old_values")
  newValues  Json?    @map("new_values")
  ipAddress  String?  @map("ip_address") @db.Inet
  userAgent  String?  @map("user_agent")
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  user User? @relation(fields: [userId], references: [id], onDelete: Restrict)

  @@index([entityId, entityName], map: "idx_audit_logs_entity")
  @@index([userId], map: "idx_audit_logs_user")
  @@index([createdAt], map: "idx_audit_logs_date")
  @@map("audit_logs")
}
